/////////////////////////////////////////////////////////////////////////
//    ATTENTION!
//    This code is automatically generated by flatdata generator.
//    Any modifications to this file will be lost upon next regeneration.
/////////////////////////////////////////////////////////////////////////
package coappearances

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"log"

	"github.com/heremaps/flatdata/flatdata-go/flatdata"
)

const (
	flatdataOffsetSizeInBytes  uint = 8
	flatdataPaddingSizeInBytes uint = 8
	indexType32SizeInBytes          = 4
	chapterSizeInBytes              = 2
	binaryRelationSizeInBytes       = 8
	unaryRelationSizeInBytes        = 6
	descriptionSizeInBytes          = 4
	nicknameSizeInBytes             = 4
	coappearanceSizeInBytes         = 8
	characterSizeInBytes            = 4
	metaSizeInBytes                 = 8
)

// /** Builtin type to for MultiVector index */
type IndexType32 struct {
	descriptor flatdata.MemoryDescriptor
	position   int
}

func (v *IndexType32) GetValue() uint64 {
	elementSizeInBits := uint(32)
	elementOffset := uint(0)
	result := flatdata.Read(v.descriptor, (uint(v.position)*8)+elementOffset, elementSizeInBits, false)
	return uint64(result)
}

func (v *IndexType32) ToString() string {
	buffer := bytes.Buffer{}
	buffer.WriteString(fmt.Sprintf(`{"name": "IndexType32", "position": %d, "attributes": {`, v.position))
	if v.descriptor != nil {
		buffer.WriteString(fmt.Sprintf(`"value": %v`, v.GetValue()))
	}
	buffer.WriteString("}}")
	return buffer.String()
}

// /**
//  * A chapter in the book.
//  */
type Chapter struct {
	descriptor flatdata.MemoryDescriptor
	position   int
}

func (v *Chapter) GetMajor() uint8 {
	elementSizeInBits := uint(4)
	elementOffset := uint(0)
	result := flatdata.Read(v.descriptor, (uint(v.position)*8)+elementOffset, elementSizeInBits, false)
	return uint8(result)
}

func (v *Chapter) GetMinor() uint8 {
	elementSizeInBits := uint(7)
	elementOffset := uint(4)
	result := flatdata.Read(v.descriptor, (uint(v.position)*8)+elementOffset, elementSizeInBits, false)
	return uint8(result)
}

func (v *Chapter) ToString() string {
	buffer := bytes.Buffer{}
	buffer.WriteString(fmt.Sprintf(`{"name": "Chapter", "position": %d, "attributes": {`, v.position))
	if v.descriptor != nil {
		buffer.WriteString(fmt.Sprintf(`"major": %v`, v.GetMajor()))
		buffer.WriteString(",")
		buffer.WriteString(fmt.Sprintf(`"minor": %v`, v.GetMinor()))
	}
	buffer.WriteString("}}")
	return buffer.String()
}

// /**
//  * A relation of a character to two other characters.
//  */
type BinaryRelation struct {
	descriptor flatdata.MemoryDescriptor
	position   int
}

func (v *BinaryRelation) GetKindRef() uint32 {
	elementSizeInBits := uint(32)
	elementOffset := uint(0)
	result := flatdata.Read(v.descriptor, (uint(v.position)*8)+elementOffset, elementSizeInBits, false)
	return uint32(result)
}

func (v *BinaryRelation) GetToARef() uint32 {
	elementSizeInBits := uint(16)
	elementOffset := uint(32)
	result := flatdata.Read(v.descriptor, (uint(v.position)*8)+elementOffset, elementSizeInBits, false)
	return uint32(result)
}

func (v *BinaryRelation) GetToBRef() uint32 {
	elementSizeInBits := uint(16)
	elementOffset := uint(48)
	result := flatdata.Read(v.descriptor, (uint(v.position)*8)+elementOffset, elementSizeInBits, false)
	return uint32(result)
}

func (v *BinaryRelation) ToString() string {
	buffer := bytes.Buffer{}
	buffer.WriteString(fmt.Sprintf(`{"name": "BinaryRelation", "position": %d, "attributes": {`, v.position))
	if v.descriptor != nil {
		buffer.WriteString(fmt.Sprintf(`"kind_ref": %v`, v.GetKindRef()))
		buffer.WriteString(",")
		buffer.WriteString(fmt.Sprintf(`"to_a_ref": %v`, v.GetToARef()))
		buffer.WriteString(",")
		buffer.WriteString(fmt.Sprintf(`"to_b_ref": %v`, v.GetToBRef()))
	}
	buffer.WriteString("}}")
	return buffer.String()
}

// /**
//  * A relation of a character to another one.
//  */
type UnaryRelation struct {
	descriptor flatdata.MemoryDescriptor
	position   int
}

func (v *UnaryRelation) GetKindRef() uint32 {
	elementSizeInBits := uint(32)
	elementOffset := uint(0)
	result := flatdata.Read(v.descriptor, (uint(v.position)*8)+elementOffset, elementSizeInBits, false)
	return uint32(result)
}

func (v *UnaryRelation) GetToRef() uint32 {
	elementSizeInBits := uint(16)
	elementOffset := uint(32)
	result := flatdata.Read(v.descriptor, (uint(v.position)*8)+elementOffset, elementSizeInBits, false)
	return uint32(result)
}

func (v *UnaryRelation) ToString() string {
	buffer := bytes.Buffer{}
	buffer.WriteString(fmt.Sprintf(`{"name": "UnaryRelation", "position": %d, "attributes": {`, v.position))
	if v.descriptor != nil {
		buffer.WriteString(fmt.Sprintf(`"kind_ref": %v`, v.GetKindRef()))
		buffer.WriteString(",")
		buffer.WriteString(fmt.Sprintf(`"to_ref": %v`, v.GetToRef()))
	}
	buffer.WriteString("}}")
	return buffer.String()
}

// /**
//  * A description of a character.
//  */
type Description struct {
	descriptor flatdata.MemoryDescriptor
	position   int
}

func (v *Description) GetRef() uint32 {
	elementSizeInBits := uint(32)
	elementOffset := uint(0)
	result := flatdata.Read(v.descriptor, (uint(v.position)*8)+elementOffset, elementSizeInBits, false)
	return uint32(result)
}

func (v *Description) ToString() string {
	buffer := bytes.Buffer{}
	buffer.WriteString(fmt.Sprintf(`{"name": "Description", "position": %d, "attributes": {`, v.position))
	if v.descriptor != nil {
		buffer.WriteString(fmt.Sprintf(`"ref": %v`, v.GetRef()))
	}
	buffer.WriteString("}}")
	return buffer.String()
}

// /**
//  * A nickname or an alternative name of a character.
//  */
type Nickname struct {
	descriptor flatdata.MemoryDescriptor
	position   int
}

func (v *Nickname) GetRef() uint32 {
	elementSizeInBits := uint(32)
	elementOffset := uint(0)
	result := flatdata.Read(v.descriptor, (uint(v.position)*8)+elementOffset, elementSizeInBits, false)
	return uint32(result)
}

func (v *Nickname) ToString() string {
	buffer := bytes.Buffer{}
	buffer.WriteString(fmt.Sprintf(`{"name": "Nickname", "position": %d, "attributes": {`, v.position))
	if v.descriptor != nil {
		buffer.WriteString(fmt.Sprintf(`"ref": %v`, v.GetRef()))
	}
	buffer.WriteString("}}")
	return buffer.String()
}

// /**
//  * An appearance of two characters in the same scene.
//  *
//  * count - multiplicity of the coappearance.
//  * first_chapter_ref - a reference to the first chapter in which characters appear. How to get the
//  * full range of chapters is described in `coappearances.cpp:read`.
//  */
type Coappearance struct {
	descriptor flatdata.MemoryDescriptor
	position   int
}

func (v *Coappearance) GetARef() uint32 {
	elementSizeInBits := uint(16)
	elementOffset := uint(0)
	result := flatdata.Read(v.descriptor, (uint(v.position)*8)+elementOffset, elementSizeInBits, false)
	return uint32(result)
}

func (v *Coappearance) GetBRef() uint32 {
	elementSizeInBits := uint(16)
	elementOffset := uint(16)
	result := flatdata.Read(v.descriptor, (uint(v.position)*8)+elementOffset, elementSizeInBits, false)
	return uint32(result)
}

func (v *Coappearance) GetCount() uint32 {
	elementSizeInBits := uint(16)
	elementOffset := uint(32)
	result := flatdata.Read(v.descriptor, (uint(v.position)*8)+elementOffset, elementSizeInBits, false)
	return uint32(result)
}

func (v *Coappearance) GetFirstChapterRef() uint32 {
	elementSizeInBits := uint(16)
	elementOffset := uint(48)
	result := flatdata.Read(v.descriptor, (uint(v.position)*8)+elementOffset, elementSizeInBits, false)
	return uint32(result)
}

func (v *Coappearance) ToString() string {
	buffer := bytes.Buffer{}
	buffer.WriteString(fmt.Sprintf(`{"name": "Coappearance", "position": %d, "attributes": {`, v.position))
	if v.descriptor != nil {
		buffer.WriteString(fmt.Sprintf(`"a_ref": %v`, v.GetARef()))
		buffer.WriteString(",")
		buffer.WriteString(fmt.Sprintf(`"b_ref": %v`, v.GetBRef()))
		buffer.WriteString(",")
		buffer.WriteString(fmt.Sprintf(`"count": %v`, v.GetCount()))
		buffer.WriteString(",")
		buffer.WriteString(fmt.Sprintf(`"first_chapter_ref": %v`, v.GetFirstChapterRef()))
	}
	buffer.WriteString("}}")
	return buffer.String()
}

// /**
//  * A character.
//  */
type Character struct {
	descriptor flatdata.MemoryDescriptor
	position   int
}

func (v *Character) GetNameRef() uint32 {
	elementSizeInBits := uint(32)
	elementOffset := uint(0)
	result := flatdata.Read(v.descriptor, (uint(v.position)*8)+elementOffset, elementSizeInBits, false)
	return uint32(result)
}

func (v *Character) ToString() string {
	buffer := bytes.Buffer{}
	buffer.WriteString(fmt.Sprintf(`{"name": "Character", "position": %d, "attributes": {`, v.position))
	if v.descriptor != nil {
		buffer.WriteString(fmt.Sprintf(`"name_ref": %v`, v.GetNameRef()))
	}
	buffer.WriteString("}}")
	return buffer.String()
}

// /**
//  * Meta information about the book.
//  */
type Meta struct {
	descriptor flatdata.MemoryDescriptor
	position   int
}

func (v *Meta) GetTitleRef() uint32 {
	elementSizeInBits := uint(32)
	elementOffset := uint(0)
	result := flatdata.Read(v.descriptor, (uint(v.position)*8)+elementOffset, elementSizeInBits, false)
	return uint32(result)
}

func (v *Meta) GetAuthorRef() uint32 {
	elementSizeInBits := uint(32)
	elementOffset := uint(32)
	result := flatdata.Read(v.descriptor, (uint(v.position)*8)+elementOffset, elementSizeInBits, false)
	return uint32(result)
}

func (v *Meta) ToString() string {
	buffer := bytes.Buffer{}
	buffer.WriteString(fmt.Sprintf(`{"name": "Meta", "position": %d, "attributes": {`, v.position))
	if v.descriptor != nil {
		buffer.WriteString(fmt.Sprintf(`"title_ref": %v`, v.GetTitleRef()))
		buffer.WriteString(",")
		buffer.WriteString(fmt.Sprintf(`"author_ref": %v`, v.GetAuthorRef()))
	}
	buffer.WriteString("}}")
	return buffer.String()
}

type GraphMetaInstance struct {
	descriptor flatdata.MemoryDescriptor
	IsOptional bool
	IsOpen     bool
}

func (v *GraphMetaInstance) Get() *Meta {
	return &Meta{
		descriptor: v.descriptor,
		position:   int(flatdataOffsetSizeInBytes),
	}
}

func (v *GraphMetaInstance) GetSize() int {
	return 1
}

func (v *GraphMetaInstance) Close() {
	v.descriptor.Close()
	v.IsOpen = false
}

func (v *GraphMetaInstance) GetSizeInBytes() int {
	return v.descriptor.Len()
}

func (v *GraphMetaInstance) ToString() string {
	buffer := bytes.Buffer{}
	buffer.WriteString(fmt.Sprintf(`{"container_type": "Instance", "size": %d, "size_in_bytes": %d, `, v.GetSize(), v.GetSizeInBytes()))
	buffer.WriteString(`"element_types": [{ "name": "Meta", "attributes": [`)
	buffer.WriteString(`{"name": "title_ref", "offset": 0, "width": 32, "is_signed": false}`)
	buffer.WriteString(",")

	buffer.WriteString(`{"name": "author_ref", "offset": 32, "width": 32, "is_signed": false}`)

	buffer.WriteString("]}]}")
	return buffer.String()
}

type GraphVerticesVector struct {
	descriptor flatdata.MemoryDescriptor
	IsOptional bool
	IsOpen     bool
}

func (v *GraphVerticesVector) Get(i int) *Character {
	return &Character{
		descriptor: v.descriptor,
		position:   int(uint(i*characterSizeInBytes) + flatdataOffsetSizeInBytes),
	}
}

func (v *GraphVerticesVector) GetSize() int {
	size := make([]byte, 8)
	_, err := v.descriptor.ReadAt(size, 0)
	if err != nil {
		return 0
	}
	intSize := binary.LittleEndian.Uint64(size)
	return int(intSize) / characterSizeInBytes
}

func (v *GraphVerticesVector) GetSlice(start, end, step int) []*Character {
	var result []*Character
	for start <= end {
		result = append(result, &Character{
			descriptor: v.descriptor,
			position:   int(uint(start*characterSizeInBytes) + flatdataOffsetSizeInBytes),
		})
		start += step
	}
	return result
}

func (v *GraphVerticesVector) Close() {
	v.descriptor.Close()
	v.IsOpen = false
}

func (v *GraphVerticesVector) GetSizeInBytes() int {
	return v.descriptor.Len()
}

func (v *GraphVerticesVector) ToString() string {
	buffer := bytes.Buffer{}
	buffer.WriteString(fmt.Sprintf(`{"container_type": "Vector", "size": %d, "size_in_bytes": %d, `, v.GetSize(), v.GetSizeInBytes()))
	buffer.WriteString(`"element_types": [{ "name": "Character", "attributes": [`)
	buffer.WriteString(`{"name": "name_ref", "offset": 0, "width": 32, "is_signed": false}`)

	buffer.WriteString("]}]}")
	return buffer.String()
}

type GraphEdgesVector struct {
	descriptor flatdata.MemoryDescriptor
	IsOptional bool
	IsOpen     bool
}

func (v *GraphEdgesVector) Get(i int) *Coappearance {
	return &Coappearance{
		descriptor: v.descriptor,
		position:   int(uint(i*coappearanceSizeInBytes) + flatdataOffsetSizeInBytes),
	}
}

func (v *GraphEdgesVector) GetSize() int {
	size := make([]byte, 8)
	_, err := v.descriptor.ReadAt(size, 0)
	if err != nil {
		return 0
	}
	intSize := binary.LittleEndian.Uint64(size)
	return int(intSize) / coappearanceSizeInBytes
}

func (v *GraphEdgesVector) GetSlice(start, end, step int) []*Coappearance {
	var result []*Coappearance
	for start <= end {
		result = append(result, &Coappearance{
			descriptor: v.descriptor,
			position:   int(uint(start*coappearanceSizeInBytes) + flatdataOffsetSizeInBytes),
		})
		start += step
	}
	return result
}

func (v *GraphEdgesVector) Close() {
	v.descriptor.Close()
	v.IsOpen = false
}

func (v *GraphEdgesVector) GetSizeInBytes() int {
	return v.descriptor.Len()
}

func (v *GraphEdgesVector) ToString() string {
	buffer := bytes.Buffer{}
	buffer.WriteString(fmt.Sprintf(`{"container_type": "Vector", "size": %d, "size_in_bytes": %d, `, v.GetSize(), v.GetSizeInBytes()))
	buffer.WriteString(`"element_types": [{ "name": "Coappearance", "attributes": [`)
	buffer.WriteString(`{"name": "a_ref", "offset": 0, "width": 16, "is_signed": false}`)
	buffer.WriteString(",")

	buffer.WriteString(`{"name": "b_ref", "offset": 16, "width": 16, "is_signed": false}`)
	buffer.WriteString(",")

	buffer.WriteString(`{"name": "count", "offset": 32, "width": 16, "is_signed": false}`)
	buffer.WriteString(",")

	buffer.WriteString(`{"name": "first_chapter_ref", "offset": 48, "width": 16, "is_signed": false}`)

	buffer.WriteString("]}]}")
	return buffer.String()
}

type GraphVerticesDataVector struct {
	descriptor flatdata.MemoryDescriptor
	IsOptional bool
	IsOpen     bool
}

func (v *GraphVerticesDataVector) Get(i int) *IndexType32 {
	return &IndexType32{
		descriptor: v.descriptor,
		position:   int(uint(i*indexType32SizeInBytes) + flatdataOffsetSizeInBytes),
	}
}

func (v *GraphVerticesDataVector) GetSize() int {
	size := make([]byte, 8)
	_, err := v.descriptor.ReadAt(size, 0)
	if err != nil {
		return 0
	}
	intSize := binary.LittleEndian.Uint64(size)
	return int(intSize) / indexType32SizeInBytes
}

func (v *GraphVerticesDataVector) GetSlice(start, end, step int) []*IndexType32 {
	var result []*IndexType32
	for start <= end {
		result = append(result, &IndexType32{
			descriptor: v.descriptor,
			position:   int(uint(start*indexType32SizeInBytes) + flatdataOffsetSizeInBytes),
		})
		start += step
	}
	return result
}

func (v *GraphVerticesDataVector) Close() {
	v.descriptor.Close()
	v.IsOpen = false
}

func (v *GraphVerticesDataVector) GetSizeInBytes() int {
	return v.descriptor.Len()
}

func (v *GraphVerticesDataVector) ToString() string {
	buffer := bytes.Buffer{}
	buffer.WriteString(fmt.Sprintf(`{"container_type": "Vector", "size": %d, "size_in_bytes": %d, `, v.GetSize(), v.GetSizeInBytes()))
	buffer.WriteString(`"element_types": [{ "name": "IndexType32", "attributes": [`)
	buffer.WriteString(`{"name": "value", "offset": 0, "width": 32, "is_signed": false}`)

	buffer.WriteString("]}]}")
	return buffer.String()
}

type GraphVerticesDataMultivector struct {
	descriptor flatdata.MemoryDescriptor
	index      *GraphVerticesDataVector
	types      map[int]interface{}
	IsOptional bool
	IsOpen     bool
}

func (v *GraphVerticesDataMultivector) Close() {
	v.descriptor.Close()
	v.IsOpen = false
}

func (v *GraphVerticesDataMultivector) GetSize() int {
	return v.index.GetSize()
}

func (v *GraphVerticesDataMultivector) GetSizeInBytes() int {
	return v.descriptor.Len()
}

func (v *GraphVerticesDataMultivector) getBucketOffset(i int) int {
	if i == v.index.GetSize() {
		return v.descriptor.Len() - int(flatdataPaddingSizeInBytes)
	}
	return int(v.index.Get(i).GetValue()) + int(flatdataOffsetSizeInBytes)
}

func (v *GraphVerticesDataMultivector) Get(i int) []interface{} {
	offset := v.getBucketOffset(i)
	nextOffset := v.getBucketOffset(i + 1)
	var result []interface{}

	for offset < nextOffset {
		elementType := flatdata.Read(v.descriptor, uint(offset*8), 8, false)
		offset++
		abstractElement, ok := v.types[elementType]
		if !ok {
			//TODO: How to process case, then type of element is not found?
			log.Println("Can't get type of element")
		}
		temp := 0
		switch element := abstractElement.(type) {
		case *Nickname:
			element.position = offset
			result = append(result, element)
			temp = nicknameSizeInBytes
		case *Description:
			element.position = offset
			result = append(result, element)
			temp = descriptionSizeInBytes
		case *UnaryRelation:
			element.position = offset
			result = append(result, element)
			temp = unaryRelationSizeInBytes
		case *BinaryRelation:
			element.position = offset
			result = append(result, element)
			temp = binaryRelationSizeInBytes
		default:
			//TODO: How to react in case if it's impossible to cast?
			log.Println("Can't cast element. Type is unknown...")
		}
		offset += temp
	}

	return result
}

func (v *GraphVerticesDataMultivector) ToString() string {
	buffer := bytes.Buffer{}
	buffer.WriteString(fmt.Sprintf(`{"container_type": "Multivector", "size": %d, "size_in_bytes": %d, "element_types": [`, v.GetSize(), v.GetSizeInBytes()))
	buffer.WriteString(`{"name": "Nickname", "attributes": [`)
	buffer.WriteString(`{"name": "ref", "offset": 0, "width": 32, "is_signed": false}`)

	buffer.WriteString("]}")
	buffer.WriteString(",")

	buffer.WriteString(`{"name": "Description", "attributes": [`)
	buffer.WriteString(`{"name": "ref", "offset": 0, "width": 32, "is_signed": false}`)

	buffer.WriteString("]}")
	buffer.WriteString(",")

	buffer.WriteString(`{"name": "UnaryRelation", "attributes": [`)
	buffer.WriteString(`{"name": "kind_ref", "offset": 0, "width": 32, "is_signed": false}`)
	buffer.WriteString(",")

	buffer.WriteString(`{"name": "to_ref", "offset": 32, "width": 16, "is_signed": false}`)

	buffer.WriteString("]}")
	buffer.WriteString(",")

	buffer.WriteString(`{"name": "BinaryRelation", "attributes": [`)
	buffer.WriteString(`{"name": "kind_ref", "offset": 0, "width": 32, "is_signed": false}`)
	buffer.WriteString(",")

	buffer.WriteString(`{"name": "to_a_ref", "offset": 32, "width": 16, "is_signed": false}`)
	buffer.WriteString(",")

	buffer.WriteString(`{"name": "to_b_ref", "offset": 48, "width": 16, "is_signed": false}`)

	buffer.WriteString("]}")

	buffer.WriteString(`], "index_type": {"name": "IndexType32", "attributes": [`)
	buffer.WriteString(`{"name": "value", "offset": 0, "width": 32, "is_signed": false}`)

	buffer.WriteString("]}}")
	return buffer.String()
}

type GraphChaptersVector struct {
	descriptor flatdata.MemoryDescriptor
	IsOptional bool
	IsOpen     bool
}

func (v *GraphChaptersVector) Get(i int) *Chapter {
	return &Chapter{
		descriptor: v.descriptor,
		position:   int(uint(i*chapterSizeInBytes) + flatdataOffsetSizeInBytes),
	}
}

func (v *GraphChaptersVector) GetSize() int {
	size := make([]byte, 8)
	_, err := v.descriptor.ReadAt(size, 0)
	if err != nil {
		return 0
	}
	intSize := binary.LittleEndian.Uint64(size)
	return int(intSize) / chapterSizeInBytes
}

func (v *GraphChaptersVector) GetSlice(start, end, step int) []*Chapter {
	var result []*Chapter
	for start <= end {
		result = append(result, &Chapter{
			descriptor: v.descriptor,
			position:   int(uint(start*chapterSizeInBytes) + flatdataOffsetSizeInBytes),
		})
		start += step
	}
	return result
}

func (v *GraphChaptersVector) Close() {
	v.descriptor.Close()
	v.IsOpen = false
}

func (v *GraphChaptersVector) GetSizeInBytes() int {
	return v.descriptor.Len()
}

func (v *GraphChaptersVector) ToString() string {
	buffer := bytes.Buffer{}
	buffer.WriteString(fmt.Sprintf(`{"container_type": "Vector", "size": %d, "size_in_bytes": %d, `, v.GetSize(), v.GetSizeInBytes()))
	buffer.WriteString(`"element_types": [{ "name": "Chapter", "attributes": [`)
	buffer.WriteString(`{"name": "major", "offset": 0, "width": 4, "is_signed": false}`)
	buffer.WriteString(",")

	buffer.WriteString(`{"name": "minor", "offset": 4, "width": 7, "is_signed": false}`)

	buffer.WriteString("]}]}")
	return buffer.String()
}

type GraphStringsRawData struct {
	descriptor flatdata.MemoryDescriptor
	IsOptional bool
	IsOpen     bool
}

func (v *GraphStringsRawData) GetValue() []byte {
	data := make([]byte, v.GetSize())
	_, err := v.descriptor.ReadAt(data, 8)
	if err != nil {
		return make([]byte, 0)
	}
	return data
}

func (v *GraphStringsRawData) GetSize() int {
	size := make([]byte, 8)
	_, err := v.descriptor.ReadAt(size, 0)
	if err != nil {
		return 0
	}
	return int(binary.LittleEndian.Uint64(size))
}

func (v *GraphStringsRawData) Close() {
	v.descriptor.Close()
	v.IsOpen = false
}

func (v *GraphStringsRawData) GetSizeInBytes() int {
	return v.descriptor.Len()
}

func (v *GraphStringsRawData) ToString() string {
	return fmt.Sprintf(`{"container_type": "RawData", "size": %d, "size_in_bytes": %d, "element_types": []}`, v.GetSize(), v.GetSizeInBytes())
}

type GraphArchive struct {
	IsOptional              bool
	IsOpen                  bool
	MetaInstance            *GraphMetaInstance
	VerticesVector          *GraphVerticesVector
	EdgesVector             *GraphEdgesVector
	VerticesDataMultivector *GraphVerticesDataMultivector
	ChaptersVector          *GraphChaptersVector
	StringsRawData          *GraphStringsRawData
}

func (v *GraphArchive) Close() {
	if v.MetaInstance.IsOpen {
		v.MetaInstance.Close()
	}
	if v.VerticesVector.IsOpen {
		v.VerticesVector.Close()
	}
	if v.EdgesVector.IsOpen {
		v.EdgesVector.Close()
	}
	if v.VerticesDataMultivector.IsOpen {
		v.VerticesDataMultivector.Close()
	}
	if v.ChaptersVector.IsOpen {
		v.ChaptersVector.Close()
	}
	if v.StringsRawData.IsOpen {
		v.StringsRawData.Close()
	}
}

func (v *GraphArchive) GetSizeInBytes() int {
	var size int
	if v.MetaInstance.IsOpen {
		size += v.MetaInstance.GetSizeInBytes()
	}
	if v.VerticesVector.IsOpen {
		size += v.VerticesVector.GetSizeInBytes()
	}
	if v.EdgesVector.IsOpen {
		size += v.EdgesVector.GetSizeInBytes()
	}
	if v.VerticesDataMultivector.IsOpen {
		size += v.VerticesDataMultivector.GetSizeInBytes()
	}
	if v.ChaptersVector.IsOpen {
		size += v.ChaptersVector.GetSizeInBytes()
	}
	if v.StringsRawData.IsOpen {
		size += v.StringsRawData.GetSizeInBytes()
	}
	return size
}

func (v *GraphArchive) ToString() string {
	buffer := bytes.Buffer{}
	buffer.WriteString(fmt.Sprintf(`{"name": "Graph", "container_type": "Archive", "size_in_bytes": %d, "resources": [`, v.GetSizeInBytes()))
	buffer.WriteString(v.MetaInstance.ToString())
	buffer.WriteString(",")

	buffer.WriteString(v.VerticesVector.ToString())
	buffer.WriteString(",")

	buffer.WriteString(v.EdgesVector.ToString())
	buffer.WriteString(",")

	buffer.WriteString(v.VerticesDataMultivector.ToString())
	buffer.WriteString(",")

	buffer.WriteString(v.ChaptersVector.ToString())
	buffer.WriteString(",")

	buffer.WriteString(v.StringsRawData.ToString())

	buffer.WriteString("]}")
	return buffer.String()
}

func OpenGraphArchive(resource flatdata.ResourceStorage) (*GraphArchive, error) {
	v := &GraphArchive{}
	// Initialize resources
	metaIsOpen := true
	metaMemoryDescriptor, _, err := resource.GetMemoryDescriptor("meta")
	if err != nil {
		log.Println(err)
		if err.Error() == flatdata.ErrorCantAccessResource {
			metaIsOpen = false
		} else {
			return v, err
		}
	}

	verticesIsOpen := true
	verticesMemoryDescriptor, _, err := resource.GetMemoryDescriptor("vertices")
	if err != nil {
		log.Println(err)
		if err.Error() == flatdata.ErrorCantAccessResource {
			verticesIsOpen = false
		} else {
			return v, err
		}
	}

	edgesIsOpen := true
	edgesMemoryDescriptor, _, err := resource.GetMemoryDescriptor("edges")
	if err != nil {
		log.Println(err)
		if err.Error() == flatdata.ErrorCantAccessResource {
			edgesIsOpen = false
		} else {
			return v, err
		}
	}

	verticesDataIsOpen := true
	verticesDataMemoryDescriptor, _, err := resource.GetMemoryDescriptor("vertices_data")
	if err != nil {
		log.Println(err)
		if err.Error() == flatdata.ErrorCantAccessResource {
			verticesDataIsOpen = false
		} else {
			return v, err
		}
	}
	verticesDataIndexMemoryDescriptor, _, err := resource.GetMemoryDescriptor("vertices_data_index")
	if err != nil {
		log.Println(err)
		if err.Error() == flatdata.ErrorCantAccessResource {
			verticesDataIsOpen = false
		} else {
			return v, err
		}
	}

	chaptersIsOpen := true
	chaptersMemoryDescriptor, _, err := resource.GetMemoryDescriptor("chapters")
	if err != nil {
		log.Println(err)
		if err.Error() == flatdata.ErrorCantAccessResource {
			chaptersIsOpen = false
		} else {
			return v, err
		}
	}

	stringsIsOpen := true
	stringsMemoryDescriptor, _, err := resource.GetMemoryDescriptor("strings")
	if err != nil {
		log.Println(err)
		if err.Error() == flatdata.ErrorCantAccessResource {
			stringsIsOpen = false
		} else {
			return v, err
		}
	}

	// Add resources to archive
	v.MetaInstance = &GraphMetaInstance{
		descriptor: metaMemoryDescriptor,
		IsOptional: false,
		IsOpen:     metaIsOpen,
	}
	v.VerticesVector = &GraphVerticesVector{
		descriptor: verticesMemoryDescriptor,
		IsOptional: false,
		IsOpen:     verticesIsOpen,
	}
	v.EdgesVector = &GraphEdgesVector{
		descriptor: edgesMemoryDescriptor,
		IsOptional: false,
		IsOpen:     edgesIsOpen,
	}
	v.VerticesDataMultivector = &GraphVerticesDataMultivector{
		descriptor: verticesDataMemoryDescriptor,
		index:      &GraphVerticesDataVector{descriptor: verticesDataIndexMemoryDescriptor},
		types: map[int]interface{}{
			0: &Nickname{descriptor: verticesDataMemoryDescriptor},
			1: &Description{descriptor: verticesDataMemoryDescriptor},
			2: &UnaryRelation{descriptor: verticesDataMemoryDescriptor},
			3: &BinaryRelation{descriptor: verticesDataMemoryDescriptor},
		},
		IsOptional: false,
		IsOpen:     verticesDataIsOpen,
	}
	v.ChaptersVector = &GraphChaptersVector{
		descriptor: chaptersMemoryDescriptor,
		IsOptional: false,
		IsOpen:     chaptersIsOpen,
	}
	v.StringsRawData = &GraphStringsRawData{
		descriptor: stringsMemoryDescriptor,
		IsOptional: false,
		IsOpen:     stringsIsOpen,
	}
	return v, nil
}
